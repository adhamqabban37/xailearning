import re
import json
import PyPDF2
import pdfplumber
from io import BytesIO
from typing import Dict, List, Any, Optional, Tuple
from pydantic import ValidationError
from models.course import (
    ResourcePack, DailyPlan, QuizBlock, Timeline, CourseMeta,
    VideoResource, CourseResource, DocResource, WebResource, PracticeResource,
    DailyAction, QuizQuestion, Assignment
)

class ParseError(Exception):
    """Custom exception for parsing errors"""
    def __init__(self, message: str, error_type: str = "parse_error"):
        self.message = message
        self.error_type = error_type
        super().__init__(self.message)

class ContentParser:
    """Advanced content parser for AI-generated learning roadmaps"""
    
    def __init__(self):
        self.json_patterns = {
            'resource_pack': [
                r'Resource Pack \(JSON\)[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'3️⃣ Resource Pack \(JSON\)[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'RESOURCE_PACK[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'resources[\"\':\s]*(\{.*?\})',
            ],
            'daily_plan': [
                r'Daily Action Plan \(JSON\)[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'4️⃣ Daily Action Plan \(JSON\)[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'DAILY_PLAN[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'daily_plan[\"\':\s]*(\{.*?\})',
            ],
            'quiz': [
                r'Quiz & Assessment \(JSON\)[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'5️⃣ Quiz & Assessment \(JSON\)[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'QUIZ[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'quiz[\"\':\s]*(\{.*?\})',
            ],
            'timeline': [
                r'Timeline \(JSON\)[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'6️⃣ Timeline \(JSON\)[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'TIMELINE[:\s]*\n```json\s*(\{.*?\})\s*```',
                r'timeline[\"\':\s]*(\{.*?\})',
            ]
        }
        
        self.section_patterns = {
            'overview': r'=== OVERVIEW ===(.*?)(?==== |$)',
            'modules': r'=== MODULES ===(.*?)(?==== |$)',
            'resource_library': r'=== RESOURCE_LIBRARY ===(.*?)(?==== |$)',
            'daily_plans': r'=== DAILY_PLANS ===(.*?)(?==== |$)',
            'quizzes': r'=== QUIZZES ===(.*?)(?==== |$)',
            'timeline': r'=== TIMELINE ===(.*?)(?==== |$)',
        }

    def extract_text_from_pdf(self, pdf_bytes: bytes) -> str:
        """Extract text from PDF with fallback strategy"""
        text = ""
        
        try:
            # First attempt: PyPDF2
            pdf_file = BytesIO(pdf_bytes)
            reader = PyPDF2.PdfReader(pdf_file)
            
            for page in reader.pages:
                page_text = page.extract_text()
                if page_text and page_text.strip():
                    text += page_text + "\n"
            
            if text.strip():
                return text
                
        except Exception as e:
            print(f"PyPDF2 failed: {e}")
        
        try:
            # Fallback: pdfplumber
            pdf_file = BytesIO(pdf_bytes)
            with pdfplumber.open(pdf_file) as pdf:
                for page in pdf.pages:
                    page_text = page.extract_text()
                    if page_text and page_text.strip():
                        text += page_text + "\n"
            
            if text.strip():
                return text
                
        except Exception as e:
            print(f"pdfplumber failed: {e}")
        
        # If we get here, text extraction failed
        raise ParseError(
            "No selectable text in PDF (likely a scan). Export a text-based PDF.",
            "pdf_extraction_failed"
        )\n\n    def detect_json_blocks(self, text: str) -> Dict[str, Any]:\n        \"\"\"Detect and extract JSON blocks from text\"\"\"\n        extracted_json = {}\n        \n        for block_type, patterns in self.json_patterns.items():\n            for pattern in patterns:\n                matches = re.finditer(pattern, text, re.DOTALL | re.IGNORECASE)\n                for match in matches:\n                    try:\n                        json_str = match.group(1)\n                        # Clean up the JSON string\n                        json_str = self._clean_json_string(json_str)\n                        parsed_json = json.loads(json_str)\n                        extracted_json[block_type] = parsed_json\n                        break  # Use first successful match\n                    except json.JSONDecodeError as e:\n                        continue\n                        \n                if block_type in extracted_json:\n                    break  # Found valid JSON for this block type\n        \n        return extracted_json\n\n    def _clean_json_string(self, json_str: str) -> str:\n        \"\"\"Clean up JSON string for parsing\"\"\"\n        # Remove markdown formatting\n        json_str = re.sub(r'```json\\s*', '', json_str)\n        json_str = re.sub(r'```\\s*$', '', json_str)\n        \n        # Remove extra whitespace\n        json_str = json_str.strip()\n        \n        # Fix common JSON issues\n        json_str = re.sub(r',\\s*}', '}', json_str)  # Remove trailing commas\n        json_str = re.sub(r',\\s*]', ']', json_str)  # Remove trailing commas in arrays\n        \n        return json_str\n\n    def parse_sections_fallback(self, text: str) -> Dict[str, str]:\n        \"\"\"Parse sections using === markers as fallback\"\"\"\n        sections = {}\n        \n        for section_name, pattern in self.section_patterns.items():\n            matches = re.search(pattern, text, re.DOTALL | re.IGNORECASE)\n            if matches:\n                sections[section_name] = matches.group(1).strip()\n        \n        return sections\n\n    def parse_course_content(self, text: str, filename: str) -> Dict[str, Any]:\n        \"\"\"Main parsing function that returns CourseJSON structure\"\"\"\n        \n        # Step 1: Try to detect JSON blocks\n        json_blocks = self.detect_json_blocks(text)\n        structured = len(json_blocks) > 0\n        \n        # Step 2: Extract basic course info\n        course_meta = self._extract_course_meta(text, filename, structured)\n        \n        # Step 3: Parse modules\n        if structured and json_blocks:\n            modules = self._parse_modules_from_json(text, json_blocks)\n        else:\n            # Fallback to section parsing\n            sections = self.parse_sections_fallback(text)\n            modules = self._parse_modules_from_sections(text, sections)\n        \n        # Step 4: Extract timeline and global resources\n        timeline = self._extract_timeline(json_blocks, text)\n        library = self._extract_global_library(json_blocks, text)\n        \n        return {\n            \"meta\": course_meta,\n            \"modules\": modules,\n            \"timeline\": timeline,\n            \"library\": library\n        }\n\n    def _extract_course_meta(self, text: str, filename: str, structured: bool) -> Dict[str, Any]:\n        \"\"\"Extract course metadata\"\"\"\n        # Extract title\n        title_patterns = [\n            r'TOPIC:\\s*([^\\n]+)',\n            r'# ([^\\n]+)',\n            r'## ([^\\n]+)',\n            r'Title:\\s*([^\\n]+)',\n        ]\n        \n        title = \"AI Learning Roadmap\"\n        for pattern in title_patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                title = match.group(1).strip()\n                break\n        \n        # Extract level\n        level_match = re.search(r'Level:\\s*([^\\n]+)', text, re.IGNORECASE)\n        level = level_match.group(1).strip() if level_match else None\n        \n        # Extract duration\n        duration_patterns = [\n            r'Duration:\\s*([^\\n]+)',\n            r'Time Commitment:\\s*([^\\n]+)',\n            r'([0-9]+\\s*weeks?)',\n            r'([0-9]+\\s*months?)',\n        ]\n        \n        duration = \"Self-paced\"\n        for pattern in duration_patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                duration = match.group(1).strip()\n                break\n        \n        # Extract milestones\n        milestones = []\n        milestone_pattern = r'milestone[s]?[:\\s]*([^\\n]+)'\n        for match in re.finditer(milestone_pattern, text, re.IGNORECASE):\n            milestones.append(match.group(1).strip())\n        \n        # Extract final competency\n        competency_patterns = [\n            r'Final competency[:\\s]*([^\\n]+)',\n            r'Goal[:\\s]*([^\\n]+)',\n            r'By the end[^\\n]*you will[^\\n]*([^\\n]+)',\n        ]\n        \n        final_competency = None\n        for pattern in competency_patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                final_competency = match.group(1).strip()\n                break\n        \n        return {\n            \"title\": title,\n            \"level\": level,\n            \"duration\": duration,\n            \"milestones\": milestones if milestones else None,\n            \"final_competency\": final_competency,\n            \"source_filename\": filename,\n            \"structured\": structured\n        }\n\n    def _parse_modules_from_json(self, text: str, json_blocks: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Parse modules when JSON blocks are available\"\"\"\n        modules = []\n        \n        # Look for module sections in text\n        module_pattern = r'Module\\s+(\\d+)[:\\s]*([^\\n]+)'\n        module_matches = list(re.finditer(module_pattern, text, re.IGNORECASE))\n        \n        if not module_matches:\n            # Fallback: look for numbered sections\n            module_pattern = r'(\\d+)\\s*[.)]\\s*([^\\n]+)'\n            module_matches = list(re.finditer(module_pattern, text, re.IGNORECASE))\n        \n        for i, match in enumerate(module_matches, 1):\n            module_title = match.group(2).strip()\n            \n            # Extract module content\n            module_content = self._extract_module_content(text, i, module_title)\n            \n            # Build module with JSON data\n            module = {\n                \"index\": i,\n                \"title\": module_title,\n                \"start_date\": module_content.get(\"start_date\"),\n                \"end_date\": module_content.get(\"end_date\"),\n                \"objectives\": module_content.get(\"objectives\", []),\n                \"summary_notes\": module_content.get(\"summary_notes\", []),\n                \"pitfalls\": module_content.get(\"pitfalls\"),\n                \"resources\": self._build_resource_pack(json_blocks.get(\"resource_pack\", {})),\n                \"daily_plan\": self._build_daily_plan(json_blocks.get(\"daily_plan\", {})),\n                \"quiz\": self._build_quiz_block(json_blocks.get(\"quiz\", {})),\n                \"assignment\": module_content.get(\"assignment\")\n            }\n            \n            modules.append(module)\n        \n        if not modules:\n            # Create a single default module\n            modules = [{\n                \"index\": 1,\n                \"title\": \"Complete Learning Roadmap\",\n                \"objectives\": [\"Complete all learning objectives\"],\n                \"summary_notes\": [\"Follow the structured learning plan\"],\n                \"resources\": self._build_resource_pack(json_blocks.get(\"resource_pack\", {})),\n                \"daily_plan\": self._build_daily_plan(json_blocks.get(\"daily_plan\", {})),\n                \"quiz\": self._build_quiz_block(json_blocks.get(\"quiz\", {}))\n            }]\n        \n        return modules\n\n    def _parse_modules_from_sections(self, text: str, sections: Dict[str, str]) -> List[Dict[str, Any]]:\n        \"\"\"Parse modules when no JSON blocks available - fallback method\"\"\"\n        modules = []\n        \n        # Look for DAY_XX patterns as a fallback\n        day_pattern = r'=== DAY_(\\d+) ===[\\s\\S]*?TOPIC:\\s*([^\\n]+)[\\s\\S]*?(?==== DAY_|$)'\n        day_matches = list(re.finditer(day_pattern, text, re.IGNORECASE))\n        \n        if day_matches:\n            # Group days into modules (e.g., every 5-7 days)\n            days_per_module = min(7, max(1, len(day_matches) // 5))  # 5 modules max\n            \n            for i in range(0, len(day_matches), days_per_module):\n                module_days = day_matches[i:i + days_per_module]\n                module_index = (i // days_per_module) + 1\n                \n                # Build module from days\n                module = self._build_module_from_days(module_days, module_index)\n                modules.append(module)\n        else:\n            # Create a single comprehensive module\n            modules = [{\n                \"index\": 1,\n                \"title\": \"Complete Learning Roadmap\",\n                \"objectives\": [\n                    \"Master the core concepts\",\n                    \"Complete practical exercises\",\n                    \"Apply knowledge in real scenarios\"\n                ],\n                \"summary_notes\": [\n                    \"Follow the structured learning approach\",\n                    \"Practice regularly for best results\",\n                    \"Review and reinforce key concepts\"\n                ],\n                \"resources\": self._extract_fallback_resources(text),\n                \"daily_plan\": self._extract_fallback_daily_plan(text),\n                \"quiz\": self._create_default_quiz()\n            }]\n        \n        return modules\n\n    def _extract_module_content(self, text: str, module_index: int, module_title: str) -> Dict[str, Any]:\n        \"\"\"Extract content for a specific module\"\"\"\n        # Look for objectives\n        objectives = []\n        obj_pattern = rf'Module\\s+{module_index}[\\s\\S]*?(?:objectives?|goals?)[:\\s]*([^\\n]+(?:\\n[-•*]\\s*[^\\n]+)*)'\n        obj_match = re.search(obj_pattern, text, re.IGNORECASE)\n        if obj_match:\n            obj_text = obj_match.group(1)\n            objectives = [obj.strip('•*- ') for obj in obj_text.split('\\n') if obj.strip()]\n        \n        if not objectives:\n            objectives = [f\"Complete {module_title} successfully\"]\n        \n        # Look for summary notes\n        summary_notes = [\n            f\"Focus on {module_title.lower()}\",\n            \"Practice the concepts regularly\",\n            \"Complete all exercises and assignments\"\n        ]\n        \n        return {\n            \"objectives\": objectives,\n            \"summary_notes\": summary_notes\n        }\n\n    def _build_resource_pack(self, resource_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Build a structured resource pack\"\"\"\n        if not resource_data:\n            return {\n                \"youtube\": [],\n                \"courses\": [],\n                \"pdfs_docs\": [],\n                \"websites\": [],\n                \"practice_platforms\": []\n            }\n        \n        # Validate and structure the resource pack\n        try:\n            resource_pack = ResourcePack(**resource_data)\n            return resource_pack.dict()\n        except ValidationError:\n            # Return with available data\n            return {\n                \"youtube\": resource_data.get(\"youtube\", []),\n                \"courses\": resource_data.get(\"courses\", []),\n                \"pdfs_docs\": resource_data.get(\"pdfs_docs\", []),\n                \"websites\": resource_data.get(\"websites\", []),\n                \"practice_platforms\": resource_data.get(\"practice_platforms\", [])\n            }\n\n    def _build_daily_plan(self, plan_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Build a structured daily plan\"\"\"\n        if not plan_data:\n            return {\n                \"day_1\": [\n                    {\"action\": \"read\", \"time\": \"30 minutes\", \"task\": \"Review course materials\"},\n                    {\"action\": \"practice\", \"time\": \"30 minutes\", \"task\": \"Complete exercises\"}\n                ]\n            }\n        \n        return plan_data\n\n    def _build_quiz_block(self, quiz_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Build a structured quiz block\"\"\"\n        if not quiz_data or \"questions\" not in quiz_data:\n            return self._create_default_quiz()\n        \n        try:\n            quiz_block = QuizBlock(**quiz_data)\n            return quiz_block.dict()\n        except ValidationError:\n            return self._create_default_quiz()\n\n    def _create_default_quiz(self) -> Dict[str, Any]:\n        \"\"\"Create a default quiz structure\"\"\"\n        return {\n            \"questions\": [\n                {\n                    \"id\": \"q1\",\n                    \"type\": \"multiple_choice\",\n                    \"question\": \"What is the most important aspect of this learning module?\",\n                    \"options\": [\n                        \"Understanding the core concepts\",\n                        \"Memorizing all details\",\n                        \"Completing assignments quickly\",\n                        \"Reading all materials\"\n                    ],\n                    \"answer\": \"Understanding the core concepts\",\n                    \"explanation\": \"Understanding core concepts provides the foundation for applying knowledge effectively.\"\n                },\n                {\n                    \"id\": \"q2\",\n                    \"type\": \"short_answer\",\n                    \"question\": \"Describe how you would apply what you've learned in a real-world scenario.\",\n                    \"key_points\": [\n                        \"Practical application\",\n                        \"Real-world context\",\n                        \"Problem-solving approach\"\n                    ]\n                }\n            ]\n        }\n\n    def _extract_timeline(self, json_blocks: Dict[str, Any], text: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Extract timeline information\"\"\"\n        if \"timeline\" in json_blocks:\n            return json_blocks[\"timeline\"]\n        \n        # Try to extract dates from text\n        start_date_match = re.search(r'start[_\\s]*date[:\\s]*([0-9-]+)', text, re.IGNORECASE)\n        end_date_match = re.search(r'end[_\\s]*date[:\\s]*([0-9-]+)', text, re.IGNORECASE)\n        \n        if start_date_match or end_date_match:\n            return {\n                \"start_date\": start_date_match.group(1) if start_date_match else None,\n                \"end_date\": end_date_match.group(1) if end_date_match else None,\n                \"milestones\": []\n            }\n        \n        return None\n\n    def _extract_global_library(self, json_blocks: Dict[str, Any], text: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Extract global resource library\"\"\"\n        if \"resource_pack\" in json_blocks:\n            return self._build_resource_pack(json_blocks[\"resource_pack\"])\n        \n        return None\n\n    def _extract_fallback_resources(self, text: str) -> Dict[str, Any]:\n        \"\"\"Extract resources using text patterns as fallback\"\"\"\n        resources = {\n            \"youtube\": [],\n            \"courses\": [],\n            \"pdfs_docs\": [],\n            \"websites\": [],\n            \"practice_platforms\": []\n        }\n        \n        # Extract YouTube links\n        youtube_pattern = r'https?://(?:www\\.)?(?:youtube\\.com|youtu\\.be)/[^\\s]+'\n        youtube_matches = re.finditer(youtube_pattern, text)\n        for match in youtube_matches:\n            resources[\"youtube\"].append({\n                \"title\": \"Video Resource\",\n                \"url\": match.group(0)\n            })\n        \n        # Extract other URLs\n        url_pattern = r'https?://[^\\s]+'\n        url_matches = re.finditer(url_pattern, text)\n        for match in url_matches:\n            url = match.group(0)\n            if \"youtube\" not in url and \"youtu.be\" not in url:\n                resources[\"websites\"].append({\n                    \"title\": \"Web Resource\",\n                    \"url\": url\n                })\n        \n        return resources\n\n    def _extract_fallback_daily_plan(self, text: str) -> Dict[str, Any]:\n        \"\"\"Extract daily plan using text patterns as fallback\"\"\"\n        # Look for DAY_XX sections\n        day_pattern = r'DAY_(\\d+)[\\s\\S]*?TOPIC[:\\s]*([^\\n]+)[\\s\\S]*?(?=DAY_|$)'\n        day_matches = list(re.finditer(day_pattern, text, re.IGNORECASE))\n        \n        daily_plan = {}\n        for match in day_matches:\n            day_num = match.group(1)\n            topic = match.group(2).strip()\n            \n            daily_plan[f\"day_{day_num}\"] = [\n                {\"action\": \"study\", \"time\": \"60 minutes\", \"task\": topic}\n            ]\n        \n        if not daily_plan:\n            daily_plan = {\n                \"day_1\": [\n                    {\"action\": \"read\", \"time\": \"30 minutes\", \"task\": \"Study course materials\"},\n                    {\"action\": \"practice\", \"time\": \"30 minutes\", \"task\": \"Complete exercises\"}\n                ]\n            }\n        \n        return daily_plan\n\n    def _build_module_from_days(self, day_matches: List, module_index: int) -> Dict[str, Any]:\n        \"\"\"Build a module from a group of days\"\"\"\n        module_title = f\"Module {module_index}: Learning Block\"\n        \n        # Extract topics from days\n        topics = []\n        daily_plan = {}\n        \n        for day_match in day_matches:\n            day_num = day_match.group(1)\n            topic = day_match.group(2).strip()\n            topics.append(topic)\n            \n            daily_plan[f\"day_{day_num}\"] = [\n                {\"action\": \"study\", \"time\": \"60 minutes\", \"task\": topic}\n            ]\n        \n        return {\n            \"index\": module_index,\n            \"title\": module_title,\n            \"objectives\": topics[:3] if topics else [\"Complete module objectives\"],\n            \"summary_notes\": [f\"Focus on {topic[:50]}...\" for topic in topics[:3]],\n            \"resources\": {\n                \"youtube\": [],\n                \"courses\": [],\n                \"pdfs_docs\": [],\n                \"websites\": [],\n                \"practice_platforms\": []\n            },\n            \"daily_plan\": daily_plan,\n            \"quiz\": self._create_default_quiz()\n        }